
DADOS PRIVADOS:

- Tempo de COMER
- Tempo de DORMIR
- Tempo de MORRER

DADO COMPARTILHADO:

- Garfos
- Thread assassina
	-Array de Tempo de ultima refeição

CADA FILOSOFO:

PRIMEIRO COMER:
	- CONSEGUE PEGAR DOIS GARFOS?
	- VAI DORMIR
	- VAI PENSAR (ESPERAR O GARFO FICAR LIVRE)
	- THREAD ASSASSINA FICA VERIFICANDO O TIME DE MORTE DE CADA UM
	- COM OPCIONAL DESATIVO (QUANDO ALGUEM MORRER) O PROGRAMA PARAR, SE ESTIVER ATIVADO (QUANDO TIVER O MINIMO DE REFEIÇOES E MORRER) O PROGRAMA PARAR.
	- MUTEX DE PRINTAGEM?
	- NAO PODE PRINTAR DEPOIS DA MORTE
	- 4 MUTEX:
		- GARFO
		- VAR DE CONTROLE
		- ULTIMA REFEIÇAO
		- TATICA BLOCK AND UNBLOCK

ROTINA DO FILOSOFO:
	- VERIFICAR SE E FINISH
	- FUNÇÃO PRA CADA AÇAO
	- THREAD + 1;
	- SMART SLEEP;
	- A CADA MILISSEGUNDO VERIFICAR SE ALGUEM
	- SE ALGUEM MORRER, RETORNE TODOS OS FILOSOFOS, DAR JOIN, E DEPOIS DESTRUA TODOS MUTEX 


long	get_time(void)

{
	struct timeval	tp;
	long		milliseconds;

	gettimeofday(&tp, NULL);
	milliseconds = tp.tv_sec * 1000;
	milliseconds += tp.tv_usec / 1000;
	return (milliseconds);
}
